---
title: 错误处理和调试指南
type: note
permalink: reference/错误处理和调试指南
---

# 错误处理和调试指南

## 错误类型

### 语法错误 (GRAMMAR_ERROR - 代码 1)
- **触发时机**: 表达式语法不符合规范
- **常见原因**:
  - 括号不匹配
  - 操作符使用不当
  - 函数参数数量错误
  - 未知的操作符或函数
  - 缺少操作数
- **示例错误**:
  - `"1 + "` → "运算符缺少右边参数"
  - `"1 + (2"` → "括号未正确关闭"
  - `"IF(1, 2)"` → "IF函数入参必须是三个" (需要三个参数)

### 计算错误 (CALCULATE_ERROR - 代码 2)
- **触发时机**: 表达式语法正确但在执行过程中出错
- **常见原因**:
  - 除零操作
  - 数学函数域错误 (如负数开平方根)
  - 类型转换失败
  - 窗口函数执行错误
- **示例错误**:
  - `"1 / 0"` → "除数不能为零"
  - `"SQRT(-1)"` → "不能对负数开平方根"

### 格式错误 (FORMAT_ERROR - 代码 3)
- **触发时机**: 数据格式不正确
- **常见原因**:
  - 日期格式错误
  - 数字格式错误
  - 字符串格式不符合要求
- **示例错误**:
  - `"TO_DATE("invalid-date")"` → "日期格式错误"
  - `"DATE_FORMAT(123, "invalid-format")"` → "格式化错误"

### 参数缺失错误 (ARG_MISS - 代码 4)
- **触发时机**: 引用了不存在的变量
- **常见原因**:
  - 变量名拼写错误
  - 变量未在参数中定义
  - 访问不存在的参数
- **示例错误**:
  - `"UNDEFINED_VAR"` → "参数缺失: UNDEFINED_VAR"

### 参数值缺失错误 (PARAM_MISS - 代码 5)
- **触发时机**: 参数容器中缺少必要的值
- **常见原因**:
  - 参数容器为空
  - 特定键值对缺失

## 调试技巧

### 1. 分解复杂表达式
复杂表达式难以调试时，可将其分解为多个简单部分：

**错误示例**:
```
IF(MAX(I01N, I02N, I03N) > 10, DATE_ADD(1, 1, TO_DATE("2023-01-01")), DATE_SUB(TO_DATE("2023-01-01"), TO_DATE("2022-01-01")))
```

**调试方法**:
```
// 步骤1: 检查MAX函数
MAX(I01N, I02N, I03N)

// 步骤2: 检查比较操作
MAX(I01N, I02N, I03N) > 10

// 步骤3: 检查IF函数的各个分支
IF(true, DATE_ADD(1, 1, TO_DATE("2023-01-01")), ...)
```

### 2. 验证数据类型
确保操作数类型匹配：
- 算术运算符要求操作数为NUMBER类型
- 比较运算符要求操作数类型一致
- 字符串操作要求操作数为TEXT类型

### 3. 检查函数参数
- 验证函数参数数量是否正确
- 验证参数类型是否符合要求
- 检查可选参数的位置是否正确

## 常见错误模式和解决方案

### 括号不匹配
**错误**: `"1 + (2 * 3"`
**解决**: 确保每对括号正确闭合

### 参数类型错误
**错误**: `MAX(1, "text", 3)`
**解决**: 确保所有参数类型一致，MAX函数只接受数值参数

### 未知变量
**错误**: `UNDEFINED_VAR`
**解决**: 确保变量在参数容器中定义，或检查变量名拼写

### 日期格式错误
**错误**: `TO_DATE("2023/13/01", "yyyy-MM-dd")`
**解决**: 确保日期值与格式字符串匹配

### 函数参数数量错误
**错误**: `IF(true, 1)` (IF函数需要三个参数)
**解决**: 检查函数文档，提供正确数量的参数

## 调试工具和方法

### 1. 使用TestUtil类
在开发环境中，可以使用TestUtil类进行单元测试：

```java
// 测试简单表达式
TestUtil.execute("1+1", 2);

// 测试预期失败情况
TestUtil.compileFail("1+", "双目运算符缺少右边参数");
```

### 2. 逐步验证
对于复杂表达式，逐步验证每个子表达式的结果。

### 3. 日志记录
在自定义函数中添加日志记录以跟踪执行流程。

## 最佳实践

### 1. 预防性验证
- 在编写表达式前，确认所有变量都已定义
- 检查函数参数类型和数量
- 验证日期格式字符串

### 2. 错误处理
- 在应用程序中捕获ExpressionException和ExecuteException
- 提供有意义的错误消息给用户
- 记录错误详情用于调试

### 3. 测试覆盖
- 为所有业务关键表达式编写单元测试
- 测试边界条件和异常情况
- 定期运行回归测试

## 性能考虑

### 1. 缓存利用
- 重复使用的表达式会被缓存
- 避免在循环中编译相同表达式

### 2. 类型转换
- 避免不必要的类型转换
- 使用适当的数据类型减少转换开销

### 3. 函数选择
- 优先使用性能更好的内置函数
- 避免复杂的嵌套函数调用

## 调试检查清单

- [ ] 表达式语法是否正确？
- [ ] 所有变量是否已定义？
- [ ] 函数参数数量是否正确？
- [ ] 函数参数类型是否匹配？
- [ ] 括号是否正确匹配？
- [ ] 日期格式是否正确？
- [ ] 是否存在除零或其他数学错误？
- [ ] 窗口函数是否在正确的数据集上运行？

通过遵循这些指导原则，可以更有效地编写、调试和维护light-expression表达式。

## 测试错误处理

### 验证错误情况的测试方法

在测试中验证错误处理的正确性：

#### 使用compileFail方法
```java
@Test
public void 语法错误测试() {
    TestUtil.compileFail("1+", "双目运算符缺少右边参数");
}
```

#### 验证异常消息
测试不仅要验证异常被抛出，还要验证异常消息的准确性。

### 常见错误测试场景

#### 括号不匹配测试
```java
TestUtil.compileFail("1 + (2", "括号未正确关闭");
```

#### 函数参数错误测试
```java
TestUtil.compileFail("IF(1, 2)", "IF函数入参必须是三个");
```

#### 类型不匹配测试
```java
TestUtil.compileFail("MAX(1, \"text\")", "MAX函数参数必须是数值类型");
```

## 调试测试失败

### 分步调试
当测试失败时，可以将复杂表达式分解为简单部分进行调试：

```java
// 复杂表达式测试失败时
String complexExpr = "IF(MAX(I01N, I02N) > 10, I01N * 2, I02N / 2)";

// 分解为多个简单测试
@Test
public void testMaxFunction() {
    TestUtil.execute("MAX(I01N, I02N)", expectedMaxValue);
}

@Test
public void testComparison() {
    TestUtil.execute("MAX(I01N, I02N) > 10", expectedBoolean);
}
```

### 日志记录
在测试环境中启用适当的日志记录以便调试。

### 断点调试
在IDE中设置断点，逐步执行表达式解析和执行过程。